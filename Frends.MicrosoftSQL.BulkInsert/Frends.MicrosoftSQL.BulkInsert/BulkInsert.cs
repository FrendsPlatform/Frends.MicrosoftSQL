using Frends.MicrosoftSQL.BulkInsert.Definitions;
using Newtonsoft.Json.Linq;
using System;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;
using System.Threading;
using System.Threading.Tasks;

namespace Frends.MicrosoftSQL.BulkInsert;

/// <summary>
/// MicrosoftSQL task.
/// </summary>
public class MicrosoftSQL
{
    /// Mem cleanup.
    static MicrosoftSQL()
    {
        var currentAssembly = Assembly.GetExecutingAssembly();
        var currentContext = AssemblyLoadContext.GetLoadContext(currentAssembly);
        if (currentContext != null)
            currentContext.Unloading += OnPluginUnloadingRequested;
    }

    /// <summary>
    /// Bulk INSERT JSON data to a MSSQL table.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.MicrosoftSQL.BulkInsert)
    /// </summary>
    /// <param name="input">Input parameters</param>
    /// <param name="options">Optional parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool Success, long Count</returns>
    public static async Task<Result> BulkInsert([PropertyTab] Input input, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        var inputJson = @"{""data"": {""Table"": " + input.InputData + @"
              }
            }";

        DataSet dataSet = JObject.Parse(inputJson)["data"].ToObject<DataSet>();
        DataTable table = dataSet.Tables["Table"];
        var rowsCopied = 0L;

        try
        {
            using var connection = new SqlConnection(input.ConnectionString);
            await connection.OpenAsync(cancellationToken).ConfigureAwait(false);
            cancellationToken.ThrowIfCancellationRequested();

            if (options.ConvertEmptyPropertyValuesToNull)
                // convert string.Empty values to null (this allows inserting data to fields which are different than text (int, ..)
                SetEmptyDataRowsToNull(dataSet);

            if (options.SqlTransactionIsolationLevel is SqlTransactionIsolationLevel.None)
                using (var sqlBulkCopy = new SqlBulkCopy(connection.ConnectionString, GetSqlBulkCopyOptions(options)))
                {
                    sqlBulkCopy.BulkCopyTimeout = options.CommandTimeoutSeconds;
                    sqlBulkCopy.DestinationTableName = input.TableName;
                    sqlBulkCopy.SqlRowsCopied += (s, e) => rowsCopied = e.RowsCopied;
                    sqlBulkCopy.NotifyAfter = options.NotifyAfter;

                    await sqlBulkCopy.WriteToServerAsync(dataSet.Tables[0], cancellationToken).ConfigureAwait(false);

                    return new Result(true, rowsCopied);
                }

            using var transaction = connection.BeginTransaction(GetIsolationLevel(options));
            using (var sqlBulkCopy = new SqlBulkCopy(connection, GetSqlBulkCopyOptions(options), transaction))
            {
                sqlBulkCopy.BulkCopyTimeout = options.CommandTimeoutSeconds;
                sqlBulkCopy.DestinationTableName = input.TableName;
                sqlBulkCopy.SqlRowsCopied += (s, e) => rowsCopied = e.RowsCopied;
                sqlBulkCopy.NotifyAfter = options.NotifyAfter;

                await sqlBulkCopy.WriteToServerAsync(dataSet.Tables[0], cancellationToken).ConfigureAwait(false);
            }

            transaction.Commit();
            return new Result(true, rowsCopied);
        }
        catch (Exception e)
        {
            var notifyRange = rowsCopied + (options.NotifyAfter-1);
            throw new Exception($"BulkInsert exception, procecced row count between: {rowsCopied} and {notifyRange} (see Options.NotifyAfter). || {e}");
        }
    }

    private static void SetEmptyDataRowsToNull(DataSet dataSet)
    {
        foreach (var table in dataSet.Tables.Cast<DataTable>())
            foreach (var row in table.Rows.Cast<DataRow>())
                foreach (var column in row.ItemArray)
                    if (column.ToString() == string.Empty)
                    {
                        var index = Array.IndexOf(row.ItemArray, column);
                        row[index] = null;
                    }
    }

    private static SqlBulkCopyOptions GetSqlBulkCopyOptions(Options options)
    {
        SqlBulkCopyOptions sqlBulkCopyOptions = (int)SqlBulkCopyOptions.Default;

        if (options.FireTriggers)
            sqlBulkCopyOptions += (int)SqlBulkCopyOptions.FireTriggers;

        if (options.KeepIdentity)
            sqlBulkCopyOptions += (int)SqlBulkCopyOptions.KeepIdentity;

        if(options.TableLock)
            sqlBulkCopyOptions += (int)SqlBulkCopyOptions.TableLock;

        if (options.KeepNulls)
            sqlBulkCopyOptions += (int)SqlBulkCopyOptions.KeepNulls;

        return sqlBulkCopyOptions;
    }

    private static IsolationLevel GetIsolationLevel (Options options) 
    {
        return options.SqlTransactionIsolationLevel switch
        {
            SqlTransactionIsolationLevel.Unspecified => IsolationLevel.Unspecified,
            SqlTransactionIsolationLevel.ReadUncommitted => IsolationLevel.ReadUncommitted,
            SqlTransactionIsolationLevel.ReadCommitted => IsolationLevel.ReadCommitted,
            SqlTransactionIsolationLevel.RepeatableRead => IsolationLevel.RepeatableRead,
            SqlTransactionIsolationLevel.Serializable => IsolationLevel.Serializable,
            SqlTransactionIsolationLevel.Snapshot => IsolationLevel.Snapshot,
            _ => IsolationLevel.ReadCommitted,
        };
    }

    private static void OnPluginUnloadingRequested(AssemblyLoadContext obj)
    {
        obj.Unloading -= OnPluginUnloadingRequested;
    }
}