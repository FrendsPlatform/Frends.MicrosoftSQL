using Frends.MicrosoftSQL.ExecuteQuery.Definitions;
using Newtonsoft.Json.Linq;
using System;
using System.ComponentModel;
using System.Data;
using System.Threading;
using System.Threading.Tasks;
using IsolationLevel = System.Data.IsolationLevel;
using Microsoft.Data.SqlClient;
using Microsoft.SqlServer.Types;

namespace Frends.MicrosoftSQL.ExecuteQuery;

/// <summary>
/// MicrosoftSQL Task.
/// </summary>
public class MicrosoftSQL
{
    /// <summary>
    /// Execute MSSQL query.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.MicrosoftSQL.ExecuteQuery)
    /// </summary>
    /// <param name="input">Input parameters</param>
    /// <param name="options">Optional parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool Success, int RecordsAffected, string ErrorMessage, JToken Data }</returns>
    public static async Task<Result> ExecuteQuery([PropertyTab] Input input, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        Result result;

        using var connection = new SqlConnection(input.ConnectionString);
        try
        {
            await connection.OpenAsync(cancellationToken);

            using var command = connection.CreateCommand();
            command.CommandTimeout = options.CommandTimeoutSeconds;
            command.CommandText = input.Query;
            command.CommandType = CommandType.Text;

            if (input.Parameters != null)
            {
                foreach (var parameter in input.Parameters)
                {
                    if (parameter.Value == null)
                    {
                        command.Parameters.AddWithValue(parameterName: parameter.Name, value: DBNull.Value);
                    }
                    else if (parameter.Value.GetType() == typeof(JValue))
                    {
                        if (((JToken)parameter.Value).Type == JTokenType.Null)
                            command.Parameters.AddWithValue(parameterName: parameter.Name, value: DBNull.Value);
                        else
                            command.Parameters.AddWithValue(parameterName: parameter.Name, value: parameter.Value.ToString());
                    }
                    else if (parameter.SqlDataType is SqlDataTypes.Auto)
                    {
                        command.Parameters.AddWithValue(parameterName: parameter.Name, value: parameter.Value ?? DBNull.Value);
                    }
                    else
                    {
                        var sqlDbType = (SqlDbType)Enum.Parse(typeof(SqlDbType), parameter.SqlDataType.ToString());
                        var commandParameter = command.Parameters.Add(parameter.Name, sqlDbType);
                        commandParameter.Value = parameter.Value ?? DBNull.Value;
                    }
                }
            }

            if (options.SqlTransactionIsolationLevel is SqlTransactionIsolationLevel.None)
                result = await ExecuteHandler(input, options, command, cancellationToken);
            else
            {
                using var transaction = connection.BeginTransaction(GetIsolationLevel(options));
                command.Transaction = transaction;
                result = await ExecuteHandler(input, options, command, cancellationToken);
            }

            return result;
        }
        catch (Exception ex)
        {
            var eMsg = $"ExecuteQuery exception: {ex}.";

            if (options.ThrowErrorOnFailure)
                throw new Exception(eMsg);

            return new Result(false, 0, eMsg, null);
        }
    }

    private static async Task<Result> ExecuteHandler(Input input, Options options, SqlCommand command, CancellationToken cancellationToken)
    {
        Result result;
        object dataObject;
        SqlDataReader dataReader = null;
        using var table = new DataTable();

        try
        {
            switch (input.ExecuteType)
            {
                case ExecuteTypes.Auto:
                    if (input.Query.ToLower().StartsWith("select"))
                    {
                        dataReader = await command.ExecuteReaderAsync(cancellationToken).ConfigureAwait(false);
                        result = new Result(true, dataReader.RecordsAffected, null, await LoadData(dataReader, cancellationToken));
                        await dataReader.CloseAsync();
                        break;
                    }
                    dataObject = await command.ExecuteNonQueryAsync(cancellationToken).ConfigureAwait(false);
                    result = new Result(true, (int)dataObject, null, JToken.FromObject(new { AffectedRows = dataObject }));
                    break;
                case ExecuteTypes.NonQuery:
                    dataObject = await command.ExecuteNonQueryAsync(cancellationToken).ConfigureAwait(false);
                    result = new Result(true, (int)dataObject, null, JToken.FromObject(new { AffectedRows = dataObject }));
                    break;
                case ExecuteTypes.Scalar:
                    dataObject = await command.ExecuteScalarAsync(cancellationToken).ConfigureAwait(false);

                    // JToken.FromObject() method can't handle SqlGeography typed objects so we convert it into string.
                    if (dataObject != null && (dataObject.GetType() == typeof(SqlGeography) || dataObject.GetType() == typeof(SqlGeometry)))
                        dataObject = dataObject.ToString();

                    result = new Result(true, 1, null, JToken.FromObject(new { Value = dataObject }));
                    break;
                case ExecuteTypes.ExecuteReader:
                    dataReader = await command.ExecuteReaderAsync(cancellationToken).ConfigureAwait(false);
                    result = new Result(true, dataReader.RecordsAffected, null, await LoadData(dataReader, cancellationToken));
                    await dataReader.CloseAsync();
                    break;
                default:
                    throw new NotSupportedException();
            }

            if (command.Transaction != null)
                await command.Transaction.CommitAsync(cancellationToken);

            return result;
        }
        catch (Exception ex)
        {
            if (dataReader != null && !dataReader.IsClosed)
                await dataReader.CloseAsync();

            if (command.Transaction is null)
            {
                if (options.ThrowErrorOnFailure)
                    throw new Exception("ExecuteHandler exception: 'Options.SqlTransactionIsolationLevel = None', so there was no transaction rollback.", ex);
                else
                    return new Result(false, 0, $"ExecuteHandler exception: 'Options.SqlTransactionIsolationLevel = None', so there was no transaction rollback. {ex}", null);
            }
            else
            {
                try
                {
                    await command.Transaction.RollbackAsync(cancellationToken);
                }
                catch (Exception rollbackEx)
                {
                    if (options.ThrowErrorOnFailure)
                        throw new Exception("ExecuteHandler exception: An exception occurred on transaction rollback.", rollbackEx);
                    else
                        return new Result(false, 0, $"ExecuteHandler exception: An exception occurred on transaction rollback. Rollback exception: {rollbackEx}. ||  Exception leading to rollback: {ex}", null);
                }

                if (options.ThrowErrorOnFailure)
                    throw new Exception("ExecuteHandler exception: (If required) transaction rollback completed without exception.", ex);
                else
                    return new Result(false, 0, $"ExecuteHandler exception: (If required) transaction rollback completed without exception. {ex}.", null);
            }
        }
    }

    private static async Task<JToken> LoadData(SqlDataReader reader, CancellationToken cancellationToken)
    {
        var table = new JArray();
        while (reader.HasRows)
        {
            while (await reader.ReadAsync(cancellationToken))
            {
                var row = new JObject();
                for (var i = 0; i < reader.FieldCount; i++)
                {
                    object fieldValue = reader.GetValue(i);
                    object value;
                    if (fieldValue == DBNull.Value)
                        value = null;
                    else if (fieldValue is SqlGeography geography)
                        value = geography.ToString();
                    else if (fieldValue is SqlGeometry geometry)
                        value = geometry.ToString();
                    else
                        value = fieldValue;

                    row.Add(new JProperty(reader.GetName(i), value));
                }

                table.Add(row);
            }
            await reader.NextResultAsync(cancellationToken).ConfigureAwait(false);
        }

        return table;
    }

    private static IsolationLevel GetIsolationLevel(Options options)
    {
        return options.SqlTransactionIsolationLevel switch
        {
            SqlTransactionIsolationLevel.Unspecified => IsolationLevel.Unspecified,
            SqlTransactionIsolationLevel.ReadUncommitted => IsolationLevel.ReadUncommitted,
            SqlTransactionIsolationLevel.ReadCommitted => IsolationLevel.ReadCommitted,
            SqlTransactionIsolationLevel.RepeatableRead => IsolationLevel.RepeatableRead,
            SqlTransactionIsolationLevel.Serializable => IsolationLevel.Serializable,
            SqlTransactionIsolationLevel.Snapshot => IsolationLevel.Snapshot,
            _ => IsolationLevel.ReadCommitted,
        };
    }
}